# postgres

Система объектно-реляционных баз данных PostgreSQL обеспечивает надежность и целостность данных.

{% hint style="info" %}
Примечание: описание для этого образа длиннее, чем ограничение длины Hub в 25000, поэтому оно было обрезано. Полное описание можно найти по адресу [https://github.com/docker-library/docs/tree/master/postgres/README.md](https://github.com/docker-library/docs/tree/master/postgres/README.md). См. [docker/hub-beta-feedback#238](https://github.com/docker/hub-beta-feedback/issues/238) для получения дополнительной информации.
{% endhint %}

## Краткий справочник

* Поддерживается: [the PostgreSQL Docker Community](https://github.com/docker-library/postgres)
* Где получить помощь: [the Docker Community Slack](https://dockr.ly/comm-slack), [Server Fault](https://serverfault.com/help/on-topic), [Unix & Linux](https://unix.stackexchange.com/help/on-topic) или [Stack Overflow](https://stackoverflow.com/help/on-topic)

## Поддерживаемые теги и соответствующие ссылки Dockerfile

Не описано. Подробности на [docker hub](https://hub.docker.com/\_/postgres).

## Краткий справочник (продолжение)

Не описано. Подробности на [docker hub](https://hub.docker.com/\_/postgres).

## Что такое PostgreSQL?

**PostgreSQL**, часто просто «Postgres», представляет собой объектно-реляционную систему управления базами данных (ORDBMS) с упором на расширяемость и соответствие стандартам. Как сервер базы данных, его основная функция заключается в безопасном хранении данных и поддержке лучших практик, а также в последующем извлечении их по запросу других программных приложений, будь то приложения на том же компьютере или те, которые работают на другом компьютере в сети (включая Интернет). Он может справляться с рабочими нагрузками, начиная от небольших одномашинных приложений и заканчивая крупными интернет-приложениями с множеством одновременно работающих пользователей. Последние версии также обеспечивают репликацию самой базы данных для обеспечения безопасности и масштабируемости.

**PostgreSQL** реализует большую часть стандарта **SQL:2011**, совместим с ACID и поддерживает транзакции (включая большинство операторов DDL), что позволяет избежать проблем с блокировкой благодаря управлению многоверсионным параллелизмом (MVCC), обеспечивает иммунитет к грязным чтениям и полную сериализуемость; обрабатывает сложные SQL-запросы, используя множество методов индексации, недоступных в других базах данных; имеет обновляемые представления и материализованные представления, триггеры, внешние ключи; поддерживает функции и хранимые процедуры, а также другие возможности расширения и имеет большое количество расширений, написанных третьими лицами. В дополнение к возможности работы с основными проприетарными базами данных и базами данных с открытым исходным кодом, **PostgreSQL** поддерживает миграцию из них благодаря обширной стандартной поддержке SQL и доступным инструментам миграции. И если использовались проприетарные расширения, благодаря своей расширяемости, которая может эмулировать многие с помощью некоторых встроенных и сторонних расширений совместимости с открытым исходным кодом, таких как для **Oracle**.

[wikipedia.org/wiki/PostgreSQL](https://en.wikipedia.org/wiki/PostgreSQL)

<figure><img src="../../.gitbook/assets/logo_postgres.png" alt=""><figcaption></figcaption></figure>

## Как использовать этот образ

### запуск экземпляра postgres

```bash
$ docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres
```

Пользователь и база данных **postgres** по умолчанию создаются в точке входа с помощью **initdb**.

База данных **postgres** — это база данных по умолчанию, предназначенная для использования пользователями, утилитами и сторонними приложениями: [postgresql.org/docs](https://www.postgresql.org/docs/14/app-initdb.html)

### ... или через psql

```bash
$ docker run -it --rm --network some-network postgres psql -h some-postgres -U postgres
psql (14.3)
Type "help" for help.

postgres=# SELECT 1;
 ?column? 
----------
        1
(1 row)
```

### ... через [docker stack deploy](https://docs.docker.com/engine/reference/commandline/stack\_deploy/) или [docker-compose](https://github.com/docker/compose)

Пример `stack.yml` для **postgres**:

```yaml
# Use postgres/example user/password credentials
version: '3.1'

services:

  db:
    image: postgres
    restart: always
    environment:
      POSTGRES_PASSWORD: example

  adminer:
    image: adminer
    restart: always
    ports:
      - 8080:8080
```

Запустите `docker stack deploy -c stack.yml postgres` (или `docker-compose -f stack.yml up`), дождитесь его полной инициализации и посетите `http://swarm-ip:8080`, `http://localhost:8080`, или `http://host-ip:8080` (при необходимости).

## Как расширить этот образ

Есть много способов расширить образ **postgres**. Не пытаясь поддержать все возможные варианты использования, вот лишь некоторые из них, которые мы сочли полезными.

### Переменные окружения

Образ **PostgreSQL** использует несколько переменных среды, которые легко пропустить. Единственная _**необходимая**_ переменная — **POSTGRES\_PASSWORD**, остальные необязательны.

{% hint style="warning" %}
специальные переменные **Docker** будут иметь эффект, только если вы запустите контейнер с пустым каталогом данных; любая ранее существовавшая база данных останется нетронутой при запуске контейнера.
{% endhint %}

### POSTGRES\_PASSWORD

Эта переменная среды необходима для использования образа **PostgreSQL**. Он не должен быть пустым или неопределенным. Эта переменная среды устанавливает пароль **суперпользователя** для PostgreSQL. Суперпользователь по умолчанию определяется переменной среды **POSTGRES\_USER**.

{% hint style="info" %}
Образ **PostgreSQL** настраивает аутентификацию **trust** локально, поэтому вы можете заметить, что пароль не требуется при подключении с **localhost** (внутри того же контейнера). Однако при подключении с другого хоста/контейнера потребуется пароль.
{% endhint %}

{% hint style="info" %}
Эта переменная определяет **пароль суперпользователя** в экземпляре **PostgreSQL**, установленный сценарием **initdb** во время первоначального запуска контейнера. Это не влияет на переменную среды **PGPASSWORD**, которая может использоваться клиентом **psql** во время выполнения, как описано в [https://www.postgresql.org/docs/14/libpq-envars.html](https://www.postgresql.org/docs/14/libpq-envars.html). **PGPASSWORD**, если он используется, будет указан как отдельная переменная среды.
{% endhint %}

### POSTGRES\_USER

Эта необязательная переменная среды используется вместе с **POSTGRES\_PASSWORD** для установки пользователя и его пароля. Эта переменная **создаст** указанного пользователя **с полномочиями суперпользователя** и базу данных с тем же именем. Если он не указан, то будет использоваться пользователь **postgres** по умолчанию.

Имейте в виду, что если этот параметр указан, **PostgreSQL** по-прежнему будет отображать _**файлы, принадлежащие этой системе баз данных, во время инициализации будут принадлежать пользователю «postgres»**_. Это относится к системному пользователю Linux (из `/etc/passwd` в образе), от имени которого работает демон **postgres**, и поэтому не имеет отношения к параметру **POSTGRES\_USER**. Дополнительные сведения см. в разделе **«Arbitrary --user Notes»**.

### POSTGRES\_DB

Эту необязательную переменную среды можно использовать для определения другого имени базы данных по умолчанию, которая создается при первом запуске образа. Если он не указан, то будет использоваться значение **POSTGRES\_USER**.

### POSTGRES\_INITDB\_ARGS

Эту необязательную переменную среды можно использовать для отправки аргументов в `initdb postgres`. Значение представляет собой строку аргументов, разделенных пробелами, как их и ожидает `postgres initdb`. Это полезно для добавления таких функций, как контрольные суммы страниц данных: `-e POSTGRES_INITDB_ARGS="--data-checksums"`.

### POSTGRES\_INITDB\_WALDIR

Эту необязательную переменную среды можно использовать для определения другого места для журнала транзакций **Postgres**. По умолчанию журнал транзакций хранится в подкаталоге основной папки данных Postgres (**PGDATA**). Иногда желательно хранить журнал транзакций в другом каталоге, который может поддерживаться хранилищем с другими характеристиками производительности или надежности.

{% hint style="info" %}
В **PostgreSQL 9.x** эта переменная имеет значение **POSTGRES\_INITDB\_XLOGDIR** (что отражает [измененное имя флага --xlogdir на --waldir в PostgreSQL 10+](https://wiki.postgresql.org/wiki/New\_in\_postgres\_10#Renaming\_of\_.22xlog.22\_to\_.22wal.22\_Globally\_.28and\_location.2Flsn.29)).
{% endhint %}

### POSTGRES\_HOST\_AUTH\_METHOD

Эта необязательная переменная может использоваться для управления методом аутентификации **auth\_method** для соединений с хостом для **всех** баз данных, **всех** пользователей и **всех** адресов. Если не указано, то используется [аутентификация по паролю scram-sha-256](https://www.postgresql.org/docs/14/auth-password.html) (в **14+**; **md5** в более старых версиях). В неинициализированной базе данных это заполнит **pg\_hba.conf** примерно такой строкой:

```bash
echo "host all all all $POSTGRES_HOST_AUTH_METHOD" >> pg_hba.conf
```

См. документацию PostgreSQL в файле [pg\_hba.conf](https://www.postgresql.org/docs/14/auth-pg-hba-conf.html) для получения дополнительной информации о возможных значениях и их значениях.

{% hint style="info" %}
Не рекомендуется использовать **trust**, поскольку оно позволяет любому подключаться без пароля, даже если он установлен (например, через **POSTGRES\_PASSWORD**). Для получения дополнительной информации см. документацию PostgreSQL по [доверительной аутентификации](https://www.postgresql.org/docs/14/auth-trust.html).
{% endhint %}

{% hint style="info" %}
Если вы установите **POSTGRES\_HOST\_AUTH\_METHOD** как доверенный **trust**, то **POSTGRES\_PASSWORD** не требуется.
{% endhint %}

{% hint style="info" %}
Если вы установите для этого альтернативное значение (например, **scram-sha-256**), вам может потребоваться дополнительный **POSTGRES\_INITDB\_ARGS** для правильной инициализации базы данных (например, `POSTGRES_INITDB_ARGS=--auth-host=scram-sha-256`).
{% endhint %}

### PGDATA

Эту необязательную переменную можно использовать для определения другого местоположения — например, подкаталога — для файлов базы данных. По умолчанию это `/var/lib/postgresql/data`. Если диск volume, который вы используете, является точкой монтирования файловой системы (например, с постоянными дисками GCE) или удаленной папкой, которую нельзя передать пользователю **postgres** (например, некоторые монтирования NFS), Postgres **initdb** рекомендует создать подкаталог для хранения данных.

Например:

```bash
$ docker run -d \
	--name some-postgres \
	-e POSTGRES_PASSWORD=mysecretpassword \
	-e PGDATA=/var/lib/postgresql/data/pgdata \
	-v /custom/mount:/var/lib/postgresql/data \
	postgres
```

Это переменная среды, не зависящая от Docker. Поскольку эта переменная используется двоичным файлом сервера **postgres** (см. [документацию PostgreSQL](https://www.postgresql.org/docs/14/app-postgres.html#id-1.9.5.14.7)), сценарий точки входа учитывает ее.

### Секреты докера

В качестве альтернативы передаче конфиденциальной информации через переменные среды **\_FILE** может быть добавлен к некоторым из ранее перечисленных переменных среды, в результате чего сценарий инициализации загружает значения для этих переменных из файлов, присутствующих в контейнере. В частности, это можно использовать для загрузки паролей из секретов Docker, хранящихся в файлах `/run/secrets/<secret_name>`. Например:

```bash
$ docker run --name some-postgres \
        -e POSTGRES_PASSWORD_FILE=/run/secrets/postgres-passwd \
        -d postgres
```

В настоящее время это поддерживается только для **POSTGRES\_INITDB\_ARGS**, **POSTGRES\_PASSWORD**, **POSTGRES\_USER** и **POSTGRES\_DB**.

### Скрипты инициализации

Если вы хотите выполнить дополнительную инициализацию в образе, производном от этого, добавьте один или несколько сценариев `*.sql`, `*.sql.gz` или `*.sh` в `/docker-entrypoint-initdb.d` (при необходимости создав каталог ). После того, как точка входа вызовет **initdb** для создания пользователя и базы данных **postgres** по умолчанию, она запустит любые файлы `*.sql`, запустит любые исполняемые сценарии `*.sh` и отыщет любые неисполняемые сценарии `*.sh`, найденные в этом каталоге, для дальнейшей инициализации перед запуск службы.

{% hint style="warning" %}
скрипты в `/docker-entrypoint-initdb.d` запускаются, только если вы запускаете контейнер с пустым каталогом данных; любая ранее существовавшая база данных останется нетронутой при запуске контейнера. Одна из распространенных проблем заключается в том, что если один из ваших скриптов `/docker-entrypoint-initdb.d` дает сбой (что приведет к выходу из скрипта точки входа) и ваш оркестратор перезапускает контейнер с уже инициализированным каталогом данных, он не будет продолжать работу с вашими скриптами.
{% endhint %}

Например, чтобы добавить дополнительного пользователя и базу данных, добавьте в `/docker-entrypoint-initdb.d/init-user-db.sh` следующее:

```bash
#!/bin/bash
set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
	CREATE USER docker;
	CREATE DATABASE docker;
	GRANT ALL PRIVILEGES ON DATABASE docker TO docker;
EOSQL
```

Эти файлы инициализации будут выполняться в отсортированном порядке имен, определенном текущей локалью, которая по умолчанию имеет значение **en\_US.utf8**. Любые файлы `*.sql` будут выполняться пользователем **POSTGRES\_USER**, который по умолчанию является _**суперпользователем postgres**_. Рекомендуется, чтобы любые команды **psql**, запускаемые внутри сценария `*.sh`, выполнялись как **POSTGRES\_USER** с использованием флага `--username "$POSTGRES_USER"`. Этот пользователь сможет подключаться без пароля благодаря наличию доверительной аутентификации для соединений сокетов Unix, осуществляемых внутри контейнера.

Кроме того, начиная с [docker-library/postgres#253](https://github.com/docker-library/postgres/pull/253), эти сценарии инициализации запускаются от имени пользователя **postgres** (или от «полупроизвольного пользователя», указанного с помощью флага `--user` при запуске `docker run`; см. раздел «Arbitrary `--user` Notes" для более подробной информации). Кроме того, начиная с [docker-library/postgres#440](https://github.com/docker-library/postgres/pull/440), временный демон, запущенный для этих сценариев инициализации, прослушивает только сокет Unix, поэтому любое использование **psql** должно отбрасывать часть имени хоста (например, см. [docker-library/postgres#474 (comment)](https://github.com/docker-library/postgres/issues/474#issuecomment-416914741) ).

### Конфигурация базы данных

Существует много способов настроить конфигурацию сервера **PostgreSQL**. Для получения информации о том, что доступно для настройки, см. [документацию PostgreSQL](https://www.postgresql.org/docs/14/runtime-config.html) для конкретной версии **PostgreSQL**, которую вы используете. Вот несколько вариантов настройки конфигурации:

* Использование пользовательского файла конфигурации. Создайте файл конфигурации и поместите его в контейнер. Если вам нужно исходное место для вашего файла конфигурации, вы можете использовать образец, предоставленный **PostgreSQL**, который доступен в контейнере в `/usr/share/postgresql/postgresql.conf.sample` (`/usr/local/share/postgresql/postgresql.conf.sample` в вариантах **Alpine**).

{% hint style="warning" %}
вы должны установить `listen_addresses = '*'`, чтобы другие контейнеры могли получить доступ к **postgres**.
{% endhint %}

```bash
$ # получить конфигурацию по умолчанию
$ docker run -i \
    --rm postgres cat /usr/share/postgresql/postgresql.conf.sample > my-postgres.conf

$ # настроить конфигурацию

$ # запустить postgres с пользовательской конфигурацией
$ docker run -d --name some-postgres \
        -v "$PWD/my-postgres.conf":/etc/postgresql/postgresql.conf \
        -e POSTGRES_PASSWORD=mysecretpassword \
        postgres \
        -c 'config_file=/etc/postgresql/postgresql.conf'
```

* Задайте параметры прямо в строке выполнения. Сценарий точки входа сделан таким образом, что любые параметры, переданные команде **docker**, будут переданы демону сервера **postgres**. Из [документов PostgreSQL](https://www.postgresql.org/docs/14/app-postgres.html#id-1.9.5.14.6.3) мы видим, что любой параметр, доступный в файле `.conf`, можно установить с помощью `-c`.

```bash
$ docker run -d --name some-postgres \
        -e POSTGRES_PASSWORD=mysecretpassword \
        postgres \
        -c shared_buffers=256MB \
        -c max_connections=200
```

### Настройка локали

Вы можете расширить образы на основе **Debian** с помощью простого **Dockerfile**, чтобы установить другую локаль. В следующем примере локаль по умолчанию будет установлена на **de\_DE.utf8**:

```docker
FROM postgres:14.3
RUN localedef -i de_DE -c -f UTF-8 -A /usr/share/locale/locale.alias de_DE.UTF-8
ENV LANG de_DE.utf8
```

Поскольку инициализация базы данных происходит только при запуске контейнера, это позволяет нам установить язык до его создания.

Также следует отметить, что варианты на основе **Alpine**, начиная с **Postgres 15**, поддерживают [локали ICU](https://www.postgresql.org/docs/15/locale.html#id-1.6.11.3.7). Предыдущие версии **Postgres**, основанные на **alpine**, не поддерживают локали; см. [«Наборы символов и локаль» в документации musl](https://wiki.musl-libc.org/functional-differences-from-glibc.html#Character-sets-and-locale) для получения более подробной информации.

Вы можете установить локали в образах на основе **Alpine** с помощью **POSTGRES\_INITDB\_ARGS**, чтобы установить другую локаль. В следующем примере локаль по умолчанию для вновь инициализированной базы данных будет установлена на **de\_DE.utf8**:

```bash
$ docker run -d \
        -e LANG=de_DE.utf8 \
        -e POSTGRES_INITDB_ARGS="--locale-provider=icu --icu-locale=de-DE" \
        -e POSTGRES_PASSWORD=mysecretpassword \
        postgres:15-alpine 
```

### Дополнительные расширения

При использовании вариантов по умолчанию (на основе **Debian**) установка дополнительных расширений (таких как **PostGIS**) должна быть такой же простой, как и установка соответствующих пакетов (конкретный пример см. на [github.com/postgis/docker-postgis](https://github.com/postgis/docker-postgis/blob/81a0b55/14-3.2/Dockerfile)).

При использовании вариантов **Alpine** любое расширение postgres, не указанное в [postgres-contrib](https://www.postgresql.org/docs/14/contrib.html), должно быть скомпилировано в ваш собственный образ (опять же, см. [github.com/postgis/docker-postgis](https://github.com/postgis/docker-postgis/blob/81a0b55/14-3.2/alpine/Dockerfile) для конкретного примера).

## Произвольные примечания `--user` (Arbitrary `--user` Notes)

Что касается [docker-library/postgres#253](https://github.com/docker-library/postgres/pull/253), этот образ поддерживает запуск от имени (в основном) произвольного пользователя с помощью `--user` при запуске **docker**. Что касается [docker-library/postgres#1018](https://github.com/docker-library/postgres/pull/1018), то же самое относится и к вариантам **Alpine**.

Основное предостережение, которое следует отметить, заключается в том, что **postgres** все равно, какой **UID** он запускает (если совпадает владелец `/var/lib/postgresql/data`), но **initdb** это не важно (и ему нужно, чтобы пользователь существовал в `/etc/passwd`):

```bash
$ docker run -it --rm --user www-data -e POSTGRES_PASSWORD=mysecretpassword postgres
The files belonging to this database system will be owned by user "www-data".
...

$ docker run -it --rm --user 1000:1000 -e POSTGRES_PASSWORD=mysecretpassword postgres
initdb: could not look up effective user ID 1000: user does not exist
```

Три самых простых способа обойти это:

1. разрешить образу использовать [библиотеку nss\_wrapper](https://cwrap.org/nss\_wrapper.html) для «подделки» содержимого `/etc/passwd` для вас (подробнее см. [docker-library/postgres#448](https://github.com/docker-library/postgres/pull/448))
2. bind-mount `/etc/passwd` только для чтения с хоста (если нужный вам **UID** является действительным пользователем на вашем хосте):

```bash
$ docker run -it --rm \
        --user "$(id -u):$(id -g)" \
        -v /etc/passwd:/etc/passwd:ro \
        -e POSTGRES_PASSWORD=mysecretpassword postgres
The files belonging to this database system will be owned by user "jsmith".
...
```

3\. инициализируйте целевой каталог отдельно от конечной среды выполнения (с промежуточным **chown**):

```bash
$ docker volume create pgdata
$ docker run -it --rm \
        -v pgdata:/var/lib/postgresql/data \
        -e POSTGRES_PASSWORD=mysecretpassword \
        postgres
The files belonging to this database system will be owned by user "postgres".
...
( once it's finished initializing successfully and is waiting for connections, stop it )
$ docker run -it --rm \
        -v pgdata:/var/lib/postgresql/data \
        bash chown -R 1000:1000 /var/lib/postgresql/data
$ docker run -it --rm --user 1000:1000 -v pgdata:/var/lib/postgresql/data postgres
LOG:  database system was shut down at 2017-01-20 00:03:23 UTC
LOG:  MultiXact member wraparound protections are now enabled
LOG:  autovacuum launcher started
LOG:  database system is ready to accept connections
```

## Предостережения

Если база данных отсутствует, когда **postgres** запускается в контейнере, то **postgres** создаст для вас базу данных по умолчанию. Хотя это ожидаемое поведение **postgres**, это означает, что в это время он не будет принимать входящие соединения. Это может вызвать проблемы при использовании инструментов автоматизации, таких как **docker-compose**, которые запускают несколько контейнеров одновременно.

Также обратите внимание, что размер `/dev/shm` по умолчанию для контейнеров составляет **64 МБ**. Если общая память исчерпана, вы столкнетесь с `ERROR: could not resize shared memory segment . . . : No space left on device`. Вы захотите передать [--shm-size=256MB](https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources), например, в `docker run` или, альтернативно, в [docker-compose](https://docs.docker.com/compose/compose-file/#shm\_size).

### Где хранить данные

{% hint style="warning" %}
Существует несколько способов хранения данных, используемых приложениями, работающими в контейнерах **Docker**. Мы рекомендуем пользователям образов **postgres** ознакомиться с доступными параметрами, в том числе:
{% endhint %}

1. Позвольте **Docker** управлять хранилищем данных вашей базы данных, [записывая файлы базы данных на диск в хост-системе, используя собственное внутреннее управление томами](https://docs.docker.com/storage/volumes/). Это значение по умолчанию, оно простое и достаточно прозрачное для пользователя. Недостатком является то, что файлы могут быть трудно найти для инструментов и приложений, которые работают непосредственно в хост-системе, то есть вне контейнеров.
2. Создайте каталог данных в хост-системе (вне контейнера) и [смонтируйте его в каталог, видимый изнутри контейнера](https://docs.docker.com/storage/bind-mounts/). Это помещает файлы базы данных в известное место в хост-системе и упрощает доступ к файлам для инструментов и приложений в хост-системе. Недостатком является то, что пользователь должен убедиться, что каталог существует, и что, например, права доступа к каталогам и другие механизмы безопасности в хост-системе настроены правильно.

Документация **Docker** является хорошей отправной точкой для понимания различных вариантов и вариантов хранения, и существует множество блогов и сообщений на форумах, в которых обсуждаются и даются советы в этой области. Мы просто покажем здесь основную процедуру для последнего варианта выше:

1. Создайте каталог данных на подходящем томе в вашей хост-системе, например, `/my/own/datadir`.
2. Запустите свой контейнер **postgres** следующим образом:

```bash
$ docker run --name some-postgres
        -v /my/own/datadir:/var/lib/postgresql/data\
        -e POSTGRES_PASSWORD=mysecretpassword \
        -d postgres:tag
```

Часть команды `-v /my/own/datadir:/var/lib/postgresql/data` монтирует каталог `/my/own/datadir` из базовой хост-системы как `/var/lib/postgresql/data` внутри контейнера, где PostgreSQL по умолчанию записывает свои файлы данных.

## Варианты образов

Образы **postgres** бывают разных видов, каждый из которых предназначен для конкретного случая использования.

### postgres:\<version>

Это образ де-факто. Если вы не уверены в своих потребностях, вы, вероятно, захотите использовать его. Он предназначен для использования как в качестве одноразового контейнера (смонтируйте исходный код и запустите контейнер для запуска вашего приложения), так и в качестве основы для создания других образов.

Некоторые из этих тегов могут иметь такие названия, как **bullseye**. Это кодовые имена наборов для выпусков [Debian](https://wiki.debian.org/DebianReleases), которые указывают, на каком выпуске основан образ. Если вашему образу необходимо установить какие-либо дополнительные пакеты помимо того, что поставляется с образом, вы, вероятно, захотите явно указать один из них, чтобы свести к минимуму поломку при выходе новых выпусков **Debian**.

### postgres:\<version>-alpine

Этот образ основан на популярном [проекте Alpine Linux](https://alpinelinux.org/), доступном в [официальном образе alpine](https://hub.docker.com/\_/alpine). **Alpine Linux** намного меньше, чем большинство базовых образов дистрибутива (\~ 5 МБ), и, таким образом, образы в целом намного меньше.

Этот вариант удобен, когда ваша главная задача — сделать конечный размер изображения как можно меньше. Основное предостережение, которое следует отметить, заключается в том, что он использует [musl libc](https://musl.libc.org/) вместо [glibc и других](https://www.etalabs.net/compare\_libcs.html), поэтому программное обеспечение часто будет сталкиваться с проблемами в зависимости от глубины их требований/предположений libc. См. [эту ветку комментариев Hacker News](https://news.ycombinator.com/item?id=10782897) для более подробного обсуждения проблем, которые могут возникнуть, и некоторых сравнений «за» и «против» использования образов на основе **Alpine**.

Чтобы минимизировать размер образа, в образы на основе **Alpine** редко включаются дополнительные связанные инструменты (такие как **git** или **bash**). Используя этот образ в качестве основы, добавьте все, что вам нужно, в свой собственный **Dockerfile** (см. [описание образа alpine](https://hub.docker.com/\_/alpine/) для примеров того, как устанавливать пакеты, если вы не знакомы).

## Лицензия

Просмотрите [информацию о лицензии](https://www.postgresql.org/about/licence/) на программное обеспечение, содержащееся в этом образе.

Как и все образы **Docker**, они, вероятно, также содержат другое программное обеспечение, которое может быть под другими лицензиями (например, **Bash** и т. д. из базового дистрибутива, а также любые прямые или косвенные зависимости от основного программного обеспечения).

Некоторая дополнительная информация о лицензии, которая может быть обнаружена автоматически, может быть найдена в [каталоге postgres/ репозитория repo-info](https://github.com/docker-library/repo-info/tree/master/repos/postgres).

Что касается использования любого предварительно созданного образа, пользователь образа несет ответственность за обеспечение того, чтобы любое использование этого образа соответствовало всем соответствующим лицензиям на все программное обеспечение, содержащееся в нем.
